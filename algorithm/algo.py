# -*- coding: utf-8 -*-
"""MakeUofT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SxMdm3sDstckEw5Ys8vUI2ZFxM6NqdUQ

Algorithm: work of Hitarth Desai, Shikhar Chaurasia
Room Tone Project.
### Import Modules
"""

!pip install open3d
!pip install trimesh

import numpy as np
import math
import open3d as o3d
import trimesh

"""### Useless Stuff"""

# Define the vertices of the cube
vertices = [
    (-0.5, -0.5, 0.5),
    (0.5, -0.5, 0.5),
    (0.5, 0.5, 0.5),
    (-0.5, 0.5, 0.5),
    (-0.5, -0.5, -0.5),
    (0.5, -0.5, -0.5),
    (0.5, 0.5, -0.5),
    (-0.5, 0.5, -0.5)
]

# Define the faces of the cube
faces = [
    (1, 2, 3, 4),
    (5, 8, 7, 6),
    (1, 5, 6, 2),
    (2, 6, 7, 3),
    (3, 7, 8, 4),
    (5, 1, 4, 8)
]

# Open the .obj file for writing
with open('cube.obj', 'w') as f:
    # Write the vertices to the file
    for v in vertices:
        f.write('v {} {} {}\n'.format(v[0], v[1], v[2]))

    # Write the faces to the file
    for face in faces:
        f.write('f {} {} {} {}\n'.format(face[0], face[1], face[2], face[3]))

mesh = o3d.io.read_triangle_mesh("cube.obj")
# print(np.asarray(mesh.triangles))

def generateV(phit, normal, cos_theta_i, startdB, distanceFromOrigin, num_samples):
    """
    Generates an array of rays using a cosine-weighted hemisphere sampling technique
    """
    V = []
    for i in range(num_samples):
        r = sampleHemisphere(normal)
        if r.dot(normal) < 0:
            r = -r
        # Calculate the reflection of the sample vector around the incident vector
        sample_reflection = r - 2 * r.dot(normal) * normal
        # Calculate the cosine factor for the specular term
        cos_theta_r = sample_reflection.dot(-cos_theta_i)
        # Calculate the dB level for the ray
        ray_dB = startdB * (cos_theta_i + cos_theta_r) / (4 * math.pi * distanceFromOrigin**2)
        # Create a new ray and add it to the list
        ray = Ray(phit, r, ray_dB)
        V.append(ray)
    return V

"""### Utility Classes"""

class Room:
    def __init__(self, path):
        self.path=path
        self.triangles=np.array([None])

    def compute_triangles(self):
        mesh = trimesh.load(self.path)
        triangles = np.array(mesh.triangles)
        new_triangles = np.array([None]*len(triangles))
        
        for i, triangle in enumerate(triangles):
            new_triangle = Triangle(i, triangle)
            new_triangle = new_triangle.compute_normal()
            new_triangles[i] = new_triangle

        self.triangles = new_triangles
        return self

class Triangle:
    def __init__(self, id, vertices):
        self.id=id
        self.vertices = np.array(vertices)
        self.normal = None

    def get_edges(self):
        edges = []
        for i in range(3):
            edge = self.vertices[(i + 1) % 3] - self.vertices[i]
            edges.append(edge)
        return edges

    def compute_normal(self):
        v1, v2, v3 = self.vertices
        vector1 = v2 - v1
        vector2 = v3 - v1
        normal = np.cross(vector1, vector2)
        
        self.normal = np.array(normal)/np.linalg.norm(np.array(normal))

        return self

    def is_point_on_plane(self, point):
        return abs(np.dot(point - self.vertices[0], self.normal)) < 1e-9

class Source:
    def __init__(self, name, origin, numrays, soundlevel):
        self.name=name
        self.origin=np.array(origin)
        self.numrays=numrays
        self.soundlevel=soundlevel

    def generate_rays(self):
        points = []
        offset = 2.0 / self.numrays
        increment = math.pi * (3.0 - math.sqrt(5.0))
        for i in range(self.numrays):
            y = ((i * offset) - 1) + (offset / 2)
            r = math.sqrt(1 - pow(y, 2))
            phi = ((i + 1) % self.numrays) * increment
            x = math.cos(phi) * r
            z = math.sin(phi) * r
            points.append(Ray(self.origin, np.array([x, y, z])-self.origin, self.soundlevel))
        return points

class Ray:
    def __init__(self, origin, direction, soundlevel):
        self.origin=origin
        # self.direction=np.array(direction)/np.linalg.norm(np.array(direction))
        self.direction=direction
        self.soundlevel=soundlevel

class Listener:
    def __init__(self, position, unit):
        self.position=np.array(position)
        self.unit=unit
        self.min_coord = self.position - 0.5 * self.unit
        self.max_coord = self.position + 0.5 * self.unit

