# -*- coding: utf-8 -*-
"""Algo_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XhRXk5j04mcgQI3SKNP3eubYXkmJar3R

### Import Modules
"""

!pip install open3d
!pip install trimesh

import numpy as np
import math
import open3d as o3d
import trimesh

"""### Helper Functions"""

def normalize(v):
    magnitude = math.sqrt(v[0]**2+v[1]**2+v[2]**2)
    if magnitude == 0:
      return np.array([0, 0, 0])
    return np.array(v)/magnitude

def line_plane_intersection(ray: Ray, triangle: Triangle):
    tolerance=math.cos(10 * math.pi / 180.0)
    line_direction = normalize(ray.direction)
    plane_point, plane_normal = triangle.vertices[0], normalize(triangle.normal)
    
    dot_product = np.dot(line_direction, plane_normal)
    if abs(dot_product) < tolerance:
        return None
    
    unit_vector = normalize(plane_point - ray.origin)
    distance = np.dot(unit_vector, plane_normal) / dot_product
    intersection_point = ray.origin + distance * line_direction
    
    return intersection_point

def reflect_ray(incident_ray: Ray, surface_normal, phit, coefficient):
  
    v1 = normalize(incident_ray.direction)
    v2 = normalize(surface_normal)
    dot_product = np.dot(v1, v2)
    sub_term = normalize(2 * dot_product * v2)
    reflection = normalize(v1 - sub_term)
    reflectedRay = Ray(phit, reflection, (1-coefficient)*incident_ray.soundlevel)
    
    return reflectedRay

def line_cube_intersection(start, direction, cube_min, cube_max):
    tmin = -np.inf
    tmax = np.inf

    for i in range(3):
        if direction[i] != 0:
            t1 = (cube_min[i] - start[i]) / direction[i]
            t2 = (cube_max[i] - start[i]) / direction[i]

            if t1 > t2:
                t1, t2 = t2, t1

            if t1 > tmin:
                tmin = t1

            if t2 < tmax:
                tmax = t2

            if tmax < 0:
                return None

        # else: return None

    if tmin > tmax:
        return None

    intersection = start + tmin * direction
    return intersection

"""### Utility Classes"""

class Room:
    def __init__(self, path):
        self.path=path
        self.volume=0
        self.vertices=list()
        self.triangles=np.array([None])
        self.mesh=None

    def compute_details(self, point):
        self.mesh = trimesh.load(self.path)
        self.volume = self.mesh.volume
        triangles = np.array(self.mesh.triangles)
        new_triangles = np.array([None]*len(triangles))

        for i, triangle in enumerate(triangles):
            new_t = [None]*3
            for j in range(3):
                new_v = triangle[j] - point
                new_t[j] = new_v
            new_triangle = Triangle(i, new_t)
            new_triangle = new_triangle.compute_normal()
            new_triangles[i] = new_triangle
        self.triangles = new_triangles
        
        return self

class Triangle:
    def __init__(self, id, vertices):
        self.id=id
        self.vertices = np.array(vertices)
        self.normal = None

    def compute_normal(self):
        v1, v2, v3 = self.vertices
        vector1 = v2 - v1
        vector2 = v3 - v1
        normal = normalize(np.cross(vector1, vector2))
        self.normal = normal

        return self

    def is_point_on_plane(self, point):
        point_vector = point - self.vertices[0]
        unit_vector = normalize(point_vector)
        unit_normal = self.normal
        dot_product = abs(np.dot(unit_vector, unit_normal))
        angle = math.acos(dot_product)

        return angle >= math.pi * 88.5 / 180.0

class Source:
    def __init__(self, name, origin, numrays, soundlevel):
        self.name=name
        self.origin=np.array(origin)
        self.numrays=numrays
        self.soundlevel=soundlevel

    def generate_rays(self):
        points = []
        for i in range(self.numrays):
            for j in range(self.numrays):
                u = (i + 0.5) / self.numrays
                v = (j + 0.5) / self.numrays
                theta = 2 * math.pi * u
                phi = math.acos(2 * v - 1)
                x = math.sin(phi) * math.cos(theta)
                y = math.sin(phi) * math.sin(theta)
                z = math.cos(phi)
                direction = normalize(np.array([x, y, z]))
                points.append(Ray(self.origin, direction, self.soundlevel))
        return points

class Ray:
    def __init__(self, origin, direction, soundlevel):
        self.origin=origin
        self.direction=normalize(direction)
        self.soundlevel=soundlevel

class Listener:
    def __init__(self, position, unit):
        self.position=np.array(position)
        self.unit=unit
        self.min_coord = self.position - 0.5 * self.unit
        self.max_coord = self.position + 0.5 * self.unit

"""### Simulation Class"""

class Simulation:
    def __init__(self, rays, reflections, file_name, decibel_level):
        self.num_rays = rays
        self.num_reflections = reflections
        self.coefficient = 0.05
        self.filename = file_name
        self.centroid = np.array([-0.0121977, 2.06714929, 1.4618923 ])
        self.decibels = decibel_level
        self.src = Source("", np.array([0, 0, 0]), self.num_rays, self.decibels)
        self.incident_rays = self.src.generate_rays()
        self.room = Room(self.filename)
        self.room = self.room.compute_details(self.centroid)
        self.triangles = self.room.triangles
        self.num_triangles = len(self.triangles)
        self.listener=Listener([2, 2, 2], 1)

    def fill_reflection_data(self):
        reflectionData=np.array([None]*self.num_rays)
        for i in range(self.num_rays):
            
            reflections = np.array([(None, -2)]*(self.num_reflections+1))
            incident_ray = self.incident_rays[i]
            reflections[0] = (incident_ray, -1)

            for j in range(self.num_reflections):
                
                incoming_ray = reflections[j][0]

                reflected_ray = None
                for k in range(self.num_triangles):
                    triangle = self.triangles[k]
                    if triangle.is_point_on_plane(incoming_ray.origin): continue

                    point_of_incidence = line_plane_intersection(incoming_ray, triangle)
                    if point_of_incidence is None: continue

                    reflected_ray = reflect_ray(incoming_ray, triangle.normal, point_of_incidence, self.coefficient)
                    reflections[j+1] = (reflected_ray, triangle.id)

                reflectionReachedListener = line_cube_intersection(incoming_ray.origin, incoming_ray.direction, self.listener.min_coord, self.listener.max_coord)
                if reflectionReachedListener is not None:
                    break;

            reflectionData[i]=reflections
            
        return reflectionData
    
    def print_reflection_data(self, reflectionData):
        for i, ray in enumerate(reflectionData):
            print("Ray", i+1, ":")
            reflections = reflectionData[i]
            for j in range(len(reflections)):
                reflected_ray = reflections[j]
                if reflected_ray[1]==-2: continue
                print("Reflected Ray", j,":", reflected_ray[0].direction, "From Triangle", reflected_ray[1])
    

    def output_amplitude_result(self, reflectionData):
        #for each ray there is going to be a list of reflections
        list_of_number_of_reflections = [0]*self.num_rays
        for i, ray in enumerate(reflectionData):
            actual_reflections = list()
            for reflection in ray:
                reflected_ray = reflection[0]
                if reflected_ray is None: break
                actual_reflections.append(reflected_ray)
            list_of_number_of_reflections[i] = len(actual_reflections)

        shortest_hit = min(list_of_number_of_reflections) - 1
        output_amplitude = reflectionData[0][0][0].soundlevel * math.pow(0.95, shortest_hit)

        return output_amplitude

    def calculate_reverb_time(self):
        return 0.161 * self.room.mesh.volume / self.room.mesh.area * 0.05

"""### Results"""

def get_output(filename):
    model_simulation = Simulation(5, 5, filename, 100)
    ref_data = model_simulation.fill_reflection_data()
    # model_simulation.print_reflection_data(ref_data)
    out_ampl = model_simulation.output_amplitude_result(ref_data)
    fraction = out_ampl/100.0 * 100.0
    print("=====")
    print("Approximate Output Volume Fraction:", fraction, "%")
    print("=====")
    reverb_time = model_simulation.calculate_reverb_time()
    print("Reverb Time:", reverb_time, "s")
    print("=====")

get_output("model.obj")
